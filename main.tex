\documentclass{aicom2e}
\usepackage[active]{srcltx}
\usepackage{ amsthm, amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{colortbl}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{caption}
\usepackage{subfig}
\usepackage{float}
\usepackage{xcolor}
\usepackage{pslatex}
\usepackage{eso-pic}
\usepackage[bottom]{footmisc}
\usepackage{url}
\usepackage{etex}


\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newcommand{\kgs}{$k$-goal search}
\newcommand{\astar}{A$^*$}

\begin{document}
\begin{frontmatter}                           % The preamble begins here.
%
%\pretitle{Pretitle}
\title{Shortest Path for K Goals}
% \runningtitle{Running title}
%\subtitle{Subtitle}
\maketitle
%
\author[]{Meir Goldenberg}
\address{Lev Academic Center\\ Jerusalem, Israel\\
	E-mail: mgoldenbe@gmail.com}
\author[]{Roni Stern}
\address{Ben Gurion University of the Negev\\ Be'er Sheva, Israel\\
E-mail: roni.stern@gmail.com}
\author[]{Ariel Felner}
\address{Ben Gurion University of the Negev\\ Be'er Sheva, Israel\\
	E-mail: felner@bgu.ac.il}

\begin{abstract}
Abstract...

\end{abstract}

\begin{keyword}
artificial intelligence\sep AI\sep Heuristic Search
\end{keyword}
%
\end{frontmatter}

\section*{Introduction}


\section{Problem Definition}

%In this section, we formally define the $k$-goal search problem.
Let $G=(V,E,w)$ be a weighted graph, where $w:E\rightarrow \mathbb{R}^+$ be the weight function, i.e., for an edge $e\in E$ the value $w(e)$ is its weight. The $k$-goal search problem is defined as follows. 

\begin{definition}[$k$-goal search]
Given a weighted graph $G$, a start vertex $s\in V$, and $k$ goal vertices 
$g_1, g_2,\ldots g_k\in V$, the task is to find $k$ paths $p_1,\ldots p_k$ 
such that for every $i\in [1,k]$ it holds that $p_i$ is a lowest-cost path from $s$ to $g_i$. 
\end{definitition}

% k searches independentaly
A trivial solution to the \kgs\ problem is to consider it as $k$ independent shortest path problem,
and use a shortest path algorithm such as Dijkstra's algorithm~\cite{} or \astar{}~\cite{}. 
In this work we explore different approaches for solving the \kgs\ problem that try to reuse information between the $k$ tasks. 


\section{One Search for $k$-Goals}


\begin{algorithm}[t!]
\begin{footnotesize}
\SetAlgoLined \SetKwBlock{BFS}{best-first-search(start state $s$, goal state $g$)}{end} \BFS{
    \open{}~$\gets\{s\}$; \\
    \While {\open{} $\neq \emptyset$} {
        $best \gets \texttt{ChooseNode}(\open{})$ \nllabel{line:open:chooseNode}\\
        Remove $best$ from \open{}\\
                \lIf {$best$ is a goal}{\Return $best$}
        \For{$n \in neighbors(best)$}{
            Add $n$ to \open{}\\
        }
    }
} \caption{Best-First Search} \label{alg:bfs}
\end{footnotesize}
\end{algorithm}


Best-first search (BFS) is a popular algorithmic framework for solving shortest path problems. 
In this section we show how BFS, and in particular \astar{}, can be extended to find $k$ shortest path. For completeness, we provide here a short backgroun on BFS and \astar{}. 

[[TODO: Background on BFS and on \astar{}. Talking also about admissible heuristics]]



\subsection{BFS for $k$-Goal Search}
\begin{algorithm}[t!]
\begin{footnotesize}
\SetAlgoLined \SetKwBlock{BFS}{best-first-search(start state $s$, goal state $g$)}{end} \BFS{
    \open{}~$\gets\{s\}$; \\
    \While {\open{} $\neq \emptyset$} {
        $best \gets \texttt{ChooseNode}(\open{})$ \nllabel{line:open:chooseNode}\\
        Remove $best$ from \open{}\\
                \lIf {$best$ is a goal}{\Return $best$}
        \For{$n \in neighbors(best)$}{
            Add $n$ to \open{}\\
        }
    }
} \caption{Best-First Search} \label{alg:bfs}
\end{footnotesize}
\end{algorithm}
To extend BFS to solve the \kgs\ problem, the following algorithmic components 
must be modified. 
\begin{itemize}
    \item {\bf Information stored per node.} When searching for a single lowest-cost path, every node in \open{} stored two values: the $g$-value and the $h$-value. To extend BFS to solve the \kgs\ problem, we store for every node $k+1$ values: the $g$-value and the $h$-value for each of the $k$ goals. Consequently, when every a node is generated, the heuristic funciton must be computed for each of the $k$ goal.
    \item {\bf Stopping condition.} When one of the goal vertices is expanded, the found path to that goal is returned to the user. However, the search does not halt until lowest-cost paths to all $k$ are found. Therefore, after a path to a goal is found the search continues, expanding the found goal vertex and inserting its children to \open{}. 
\end{itemize}
Note that after finding a lowest-cost path to a goal $g_i$ there is no point in
computing the $h$-value for it. 

In addition to these easy-to-implement changes, there is the question of which node to choose to expand in every iteration. In \astar{}, the node with the minimal $f=g+h$ value is chosen. 
In \kgs{}, however, there are multiple $h$ values and correspondingly multiple $f$ values, one per goal. This raises the question of how to choose the best node in \open{}
 when solving the \kgs{} problem?
 
 
 One way to answer this question is by choosing the node with the 





extend the information stored in a node in \open{}. 


% Analysis
It is common to estimate the runtime of BFS by counting the number of nodes that are expanded until the goal is found. 

\section{Experimental Results}


\subsection*{Related work}

There are several well-studied graph problems that are related to $k$-goal search. In the traveling salesman problem (TSP), we aim to find a shortest path that passes through a set of vertices. 
...


% \begin{figure}[!htbp]
%   \centering
%   \includegraphics[width=1\hsize]{filename.eps}
%   \caption{caption} \label{fig:label}
% \end{figure}

\section*{Acknowledgements}
Thanks!

\bibliographystyle{abbrv}
\bibliography{library}

\end{document}
